<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>指令詳解: tcpdump</title>
    <style>
        /* [這裡的 CSS 樣式與之前頁面完全相同] */
        body {
            font-family: "Courier New", Courier, monospace;
            line-height: 1.6;
            background-color: #000;
            color: #0F0;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        #matrixCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        .container {
            position: relative;
            z-index: 2;
            max-width: 900px;
            margin: 50px auto;
            background-color: rgba(0, 0, 0, 0.75);
            padding: 30px;
            border-radius: 10px;
            border: 1px solid #0056b3;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
            max-height: 85vh;
            overflow-y: auto;
        }
        .back-link {
            display: inline-block;
            margin-bottom: 20px;
            color: #00ff00;
            text-decoration: none;
            padding: 8px 15px;
            border: 1px solid #00ff00;
            border-radius: 5px;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .back-link:hover {
            background-color: #00ff00;
            color: #000;
            text-shadow: none;
        }
        h1 {
            border-bottom: 2px solid #0056b3;
            padding-bottom: 10px;
            color: #00ff00;
            text-shadow: 0 0 5px #00ff00;
        }
        h2 {
            color: #00cc00;
            margin-top: 25px;
            border-bottom: 1px dashed #0056b3;
            padding-bottom: 5px;
        }
        h3 {
            color: #00ff88;
            margin-top: 20px;
        }
        pre {
            background-color: rgba(0, 0, 0, 0.8);
            color: #00ff00;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            border: 1px solid #00aa00;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
            margin-bottom: 20px;
        }
        code {
            font-family: "Courier New", Courier, monospace;
            font-size: 0.95em;
        }
        p {
            margin-bottom: 15px;
        }
        ul {
            list-style: none;
            padding-left: 0;
        }
        ul li {
            margin-bottom: 8px;
            position: relative;
            padding-left: 20px;
        }
        ul li::before {
            content: "•";
            color: #00ff00;
            position: absolute;
            left: 0;
            font-size: 1.2em;
            line-height: 1.6;
        }
        /* 【重要】紅色警告框 */
        .danger-warning {
            background-color: rgba(255, 0, 0, 0.1); /* 紅色警告 */
            border: 1px solid #cc0000;
            color: #ff4444; /* 亮紅色文字 */
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            margin-bottom: 20px;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.3);
        }
        .danger-warning strong {
            color: #ff0000; /* 強調紅色 */
        }
    </style>
</head>
<body>

    <canvas id="matrixCanvas"></canvas>

    <div class="container">
        <a href="matrix_links.html" class="back-link">← 返回筆記主頁</a>

        <h1>指令詳解: `tcpdump` (網路診斷)</h1>

        <div class="danger-warning">
            <strong>【重要】法律與道德警告</strong>
            <p><code>tcpdump</code> 是一個網路封包分析工具。它會抓取並顯示流經您網路介面的所有流量。</p>
            <p><strong>在未經授權的網路上使用 `tcpdump` 竊聽他人流量 (例如在執行 ARP 欺騙後) 是一種嚴重的**違法竊聽行為**。</strong></p>
            <p>本教學僅專注於**合法和防禦性**用途：診斷**您自己**的電腦或您有權管理的網路，以排除故障和偵測異常。</p>
        </div>

        <p><code>tcpdump</code> 就像是您網路的「顯微鏡」。它讓您能即時看到網路卡上傳送和接收的每一個封包。這對於網路管理員來說，是排除「為什麼連不上？」或「是什麼佔用了我的頻寬？」等問題的無價之寶。</</p>

        <h2>基本用法 (安全診斷)</h2>

        <h3>1. 監聽特定介面</h3>
        <p>如果不指定介面，<code>tcpdump</code> 會自動選一個。最好明確指定您想監聽的介面（使用 `ip addr` 查看您的介面名稱）。</p>
        <pre><code># 監聽您的乙太網路卡 (例如 eth0)
sudo tcpdump -i eth0

# 監聽您的 Wi-Fi 介面 (例如 wlan0)
sudo tcpdump -i wlan0

# 監聽本機環回介面 (看本機程式間的通訊)
sudo tcpdump -i lo</code></pre>
        <ul>
            <li><code>-i</code>: 指定介面 (interface)。</li>
            <li><code>sudo</code>: 監聽網路通常需要系統管理員權限。</li>
            <li>按 `Ctrl+C` 停止抓取。</li>
        </ul>

        <h3>2. 禁用名稱解析 (更快速)</h3>
        <p>預設情況下，<code>tcpdump</code> 會嘗試將 IP 位址反解為主機名稱 (例如 `8.8.8.8` -> `dns.google`)。使用 <code>-n</code> 可以關閉此功能，讓輸出更乾淨、更即時。</p>
        <pre><code>sudo tcpdump -i eth0 -n</code></pre>

        <h2>【核心技能】使用過濾器 (Filters)</h2>
        <p>直接執行 <code>tcpdump</code> 會顯示所有流量，資訊量太大。真正的威力在於「過濾」。</p>

        <h3>1. 過濾主機 (Host)</h3>
        <p>只想看與特定主機（例如 Google 的 DNS 伺服器）的通訊。</p>
        <pre><code># 只顯示與 8.8.8.8 相關的所有流量
sudo tcpdump -i eth0 -n host 8.8.8.8</code></pre>

        <h3>2. 過濾協定 (Protocol)</h3>
        <p>只想看特定協定的流量。這在診斷時非常有用。</p>
        <pre><code># 只顯示 ICMP 流量 (例如 PING)
# (您可以在另一個終端機 ping 8.8.8.8 看看)
sudo tcpdump -i eth0 -n icmp</code></pre>
        <pre><code># 只顯示 DNS 查詢流量 (埠 53)
sudo tcpdump -i eth0 -n port 53</code></pre>

        <h3>3. 組合過濾器 (AND, OR, NOT)</h3>
        <p>您可以像寫程式一樣組合條件。</p>
        <pre><code># 顯示來自 192.168.1.100 且 目的埠為 22 (SSH) 的流量
sudo tcpdump -i eth0 -n "src host 192.168.1.100 and dst port 22"</code></pre>
        <ul>
            <li><code>src host</code>: 來源 IP。</li>
            <li><code>dst port</code>: 目的埠。</li>
            <li><code>"..."</code>: 當過濾器變複雜時，用引號包起來是個好習慣。</li>
        </ul>

        <h2>如何解讀輸出 (診斷觀點)</h2>
        <p><code>tcpdump</code> 的輸出格式非常緊湊：</p>
        <pre><code>[時間戳] [協定] [來源IP].[來源埠] > [目的IP].[目的埠]: [封包資訊]</code></pre>
        <p>範例 (一次 PING)：</p>
        <pre><code>02:30:01.123456 IP 192.168.1.50 > 8.8.8.8: ICMP echo request, id 1234, seq 1
02:30:01.123499 IP 8.8.8.8 > 192.168.1.50: ICMP echo reply, id 1234, seq 1</code></pre>
        <ul>
            <li>第一行是您的電腦 (`1.50`) 向 Google (`8.8.8.8`) 發出一個 `echo request` (Ping 請求)。</li>
            <li>第二行是 Google 回應了一個 `echo reply` (Ping 回應)。</li>
            <li>**診斷**：如果您只看到第一行而沒有第二行，那就表示您的封包出去了，但回應沒回來（可能被防火牆擋住，或對方主機沒開）。</li>
        </ul>
        
        <h2>儲存封包 (PCAP) 以供日後分析</h2>
        <p>有時候您需要抓取一段時間的流量，然後使用更強大的圖形工具 (如 `Wireshark`) 進行深入分析。</p>
        <pre><code># 抓取 100 個封包 (-c 100)
# 並將原始封包寫入 (-w) 一個檔案
sudo tcpdump -i eth0 -n -c 100 -w my_capture.pcap</code></pre>
        <ul>
            <li><code>-w</code>: 將原始封包寫入 (Write) 檔案，而不是顯示在螢幕上。</li>
            <li><code>-c</code>: 只抓取 (Count) 100 個封包就停止。</li>
            <li><code>.pcap</code>: 這是封包抓取檔案的標準副檔名。</li>
        </ul>
        <p>之後您就可以使用 <code>wireshark my_capture.pcap</code> 來開啟這個檔案進行詳細分析。</p>
        
        <p style="color: #ffff00; margin-top: 20px;">總結：<code>tcpdump</code> 是一個強大的「防禦」和「診斷」工具。請負責任地使用它來了解和保護您自己的網路。</p>

    </div>

    <script>
        /* [這裡的 JavaScript 腳本與之前相同] */
        const canvas = document.getElementById('matrixCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const binary = '01';
        const fontSize = 16;
        const columns = Math.floor(canvas.width / fontSize);
        const drops = [];
        for (let x = 0; x < columns; x++) {
            drops[x] = 1;
        }
        function draw() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#0F0';
            ctx.font = `${fontSize}px "Courier New"`;
            for (let i = 0; i < drops.length; i++) {
                const text = binary.charAt(Math.floor(Math.random() * binary.length));
                const x = i * fontSize;
                const y = drops[i] * fontSize;
                ctx.fillText(text, x, y);
                if (y > canvas.height && Math.random() > 0.975) {
                    drops[i] = 0;
                }
                drops[i]++;
            }
        }
        setInterval(draw, 33);
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>

</body>
</html>
